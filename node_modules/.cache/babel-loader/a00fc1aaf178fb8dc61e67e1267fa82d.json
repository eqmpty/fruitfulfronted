{"ast":null,"code":"'use strict';\n/**\n * Module dependencies.\n */\n\nconst raw = require('raw-body');\n\nconst inflate = require('inflation');\n\nconst utils = require('./utils'); // Allowed whitespace is defined in RFC 7159\n// http://www.rfc-editor.org/rfc/rfc7159.txt\n\n\nconst strictJSONReg = /^[\\x20\\x09\\x0a\\x0d]*(\\[|\\{)/;\n/**\n * Return a Promise which parses json requests.\n *\n * Pass a node request or an object with `.req`,\n * such as a koa Context.\n *\n * @param {Request} req\n * @param {Options} [opts]\n * @return {Function}\n * @api public\n */\n\nmodule.exports = async function (req, opts) {\n  req = req.req || req;\n  opts = utils.clone(opts); // defaults\n\n  let len = req.headers['content-length'];\n  const encoding = req.headers['content-encoding'] || 'identity';\n  if (len && encoding === 'identity') opts.length = len = ~~len;\n  opts.encoding = opts.encoding || 'utf8';\n  opts.limit = opts.limit || '1mb';\n  const strict = opts.strict !== false;\n  const str = await raw(inflate(req), opts);\n\n  try {\n    const parsed = parse(str);\n    return opts.returnRawBody ? {\n      parsed,\n      raw: str\n    } : parsed;\n  } catch (err) {\n    err.status = 400;\n    err.body = str;\n    throw err;\n  }\n\n  function parse(str) {\n    if (!strict) return str ? JSON.parse(str) : str; // strict mode always return object\n\n    if (!str) return {}; // strict JSON test\n\n    if (!strictJSONReg.test(str)) {\n      throw new Error('invalid JSON, only supports object and array');\n    }\n\n    return JSON.parse(str);\n  }\n};","map":{"version":3,"sources":["/home/ouroboroser/Рабочий стол/try/node_modules/co-body/lib/json.js"],"names":["raw","require","inflate","utils","strictJSONReg","module","exports","req","opts","clone","len","headers","encoding","length","limit","strict","str","parsed","parse","returnRawBody","err","status","body","JSON","test","Error"],"mappings":"AAAA;AAEA;;;;AAIA,MAAMA,GAAG,GAAGC,OAAO,CAAC,UAAD,CAAnB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,SAAD,CAArB,C,CAEA;AACA;;;AACA,MAAMG,aAAa,GAAG,6BAAtB;AAEA;;;;;;;;;;;;AAYAC,MAAM,CAACC,OAAP,GAAiB,gBAAeC,GAAf,EAAoBC,IAApB,EAA0B;AACzCD,EAAAA,GAAG,GAAGA,GAAG,CAACA,GAAJ,IAAWA,GAAjB;AACAC,EAAAA,IAAI,GAAGL,KAAK,CAACM,KAAN,CAAYD,IAAZ,CAAP,CAFyC,CAIzC;;AACA,MAAIE,GAAG,GAAGH,GAAG,CAACI,OAAJ,CAAY,gBAAZ,CAAV;AACA,QAAMC,QAAQ,GAAGL,GAAG,CAACI,OAAJ,CAAY,kBAAZ,KAAmC,UAApD;AACA,MAAID,GAAG,IAAIE,QAAQ,KAAK,UAAxB,EAAoCJ,IAAI,CAACK,MAAL,GAAcH,GAAG,GAAG,CAAC,CAACA,GAAtB;AACpCF,EAAAA,IAAI,CAACI,QAAL,GAAgBJ,IAAI,CAACI,QAAL,IAAiB,MAAjC;AACAJ,EAAAA,IAAI,CAACM,KAAL,GAAaN,IAAI,CAACM,KAAL,IAAc,KAA3B;AACA,QAAMC,MAAM,GAAGP,IAAI,CAACO,MAAL,KAAgB,KAA/B;AAEA,QAAMC,GAAG,GAAG,MAAMhB,GAAG,CAACE,OAAO,CAACK,GAAD,CAAR,EAAeC,IAAf,CAArB;;AACA,MAAI;AACF,UAAMS,MAAM,GAAGC,KAAK,CAACF,GAAD,CAApB;AACA,WAAOR,IAAI,CAACW,aAAL,GAAqB;AAAEF,MAAAA,MAAF;AAAUjB,MAAAA,GAAG,EAAEgB;AAAf,KAArB,GAA4CC,MAAnD;AACD,GAHD,CAGE,OAAOG,GAAP,EAAY;AACZA,IAAAA,GAAG,CAACC,MAAJ,GAAa,GAAb;AACAD,IAAAA,GAAG,CAACE,IAAJ,GAAWN,GAAX;AACA,UAAMI,GAAN;AACD;;AAED,WAASF,KAAT,CAAeF,GAAf,EAAoB;AAClB,QAAI,CAACD,MAAL,EAAa,OAAOC,GAAG,GAAGO,IAAI,CAACL,KAAL,CAAWF,GAAX,CAAH,GAAqBA,GAA/B,CADK,CAElB;;AACA,QAAI,CAACA,GAAL,EAAU,OAAO,EAAP,CAHQ,CAIlB;;AACA,QAAI,CAACZ,aAAa,CAACoB,IAAd,CAAmBR,GAAnB,CAAL,EAA8B;AAC5B,YAAM,IAAIS,KAAJ,CAAU,8CAAV,CAAN;AACD;;AACD,WAAOF,IAAI,CAACL,KAAL,CAAWF,GAAX,CAAP;AACD;AACF,CAhCD","sourcesContent":["'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst raw = require('raw-body');\nconst inflate = require('inflation');\nconst utils = require('./utils');\n\n// Allowed whitespace is defined in RFC 7159\n// http://www.rfc-editor.org/rfc/rfc7159.txt\nconst strictJSONReg = /^[\\x20\\x09\\x0a\\x0d]*(\\[|\\{)/;\n\n/**\n * Return a Promise which parses json requests.\n *\n * Pass a node request or an object with `.req`,\n * such as a koa Context.\n *\n * @param {Request} req\n * @param {Options} [opts]\n * @return {Function}\n * @api public\n */\n\nmodule.exports = async function(req, opts) {\n  req = req.req || req;\n  opts = utils.clone(opts);\n\n  // defaults\n  let len = req.headers['content-length'];\n  const encoding = req.headers['content-encoding'] || 'identity';\n  if (len && encoding === 'identity') opts.length = len = ~~len;\n  opts.encoding = opts.encoding || 'utf8';\n  opts.limit = opts.limit || '1mb';\n  const strict = opts.strict !== false;\n\n  const str = await raw(inflate(req), opts);\n  try {\n    const parsed = parse(str);\n    return opts.returnRawBody ? { parsed, raw: str } : parsed;\n  } catch (err) {\n    err.status = 400;\n    err.body = str;\n    throw err;\n  }\n\n  function parse(str) {\n    if (!strict) return str ? JSON.parse(str) : str;\n    // strict mode always return object\n    if (!str) return {};\n    // strict JSON test\n    if (!strictJSONReg.test(str)) {\n      throw new Error('invalid JSON, only supports object and array');\n    }\n    return JSON.parse(str);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}