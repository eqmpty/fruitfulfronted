{"ast":null,"code":"'use strict';\n\nconst pAny = require('p-any');\n\nconst unless = require('koa-unless');\n\nconst verify = require('./verify');\n\nconst getSecret = require('./get-secret');\n\nconst resolveAuthHeader = require('./resolvers/auth-header');\n\nconst resolveCookies = require('./resolvers/cookie');\n\nmodule.exports = (opts = {}) => {\n  const {\n    debug,\n    getToken,\n    isRevoked,\n    key = 'user',\n    passthrough,\n    tokenKey\n  } = opts;\n  const tokenResolvers = [resolveCookies, resolveAuthHeader];\n\n  if (getToken && typeof getToken === 'function') {\n    tokenResolvers.unshift(getToken);\n  }\n\n  const middleware = async function jwt(ctx, next) {\n    let token;\n    tokenResolvers.find(resolver => token = resolver(ctx, opts));\n\n    if (!token && !passthrough) {\n      ctx.throw(401, debug ? 'Token not found' : 'Authentication Error');\n    }\n\n    let {\n      state: {\n        secret = opts.secret\n      }\n    } = ctx;\n\n    try {\n      if (typeof secret === 'function') {\n        secret = await getSecret(secret, token);\n      }\n\n      if (!secret) {\n        throw new Error('Secret not provided');\n      }\n\n      let secrets = Array.isArray(secret) ? secret : [secret];\n      const decodedTokens = secrets.map(async s => {\n        return await verify(token, s, opts);\n      });\n      const decodedToken = await pAny(decodedTokens).catch(function (err) {\n        if (err instanceof pAny.AggregateError) {\n          for (const e of err) {\n            throw e;\n          }\n        } else {\n          throw err;\n        }\n      });\n\n      if (isRevoked) {\n        const tokenRevoked = await isRevoked(ctx, decodedToken, token);\n\n        if (tokenRevoked) {\n          throw new Error('Token revoked');\n        }\n      }\n\n      ctx.state[key] = decodedToken;\n\n      if (tokenKey) {\n        ctx.state[tokenKey] = token;\n      }\n    } catch (e) {\n      if (!passthrough) {\n        const msg = debug ? e.message : 'Authentication Error';\n        ctx.throw(401, msg, {\n          originalError: e\n        });\n      } else {\n        //lets downstream middlewares handle JWT exceptions\n        ctx.state.jwtOriginalError = e;\n      }\n    }\n\n    return next();\n  };\n\n  middleware.unless = unless;\n  return middleware;\n};","map":{"version":3,"sources":["/home/ouroboroser/Рабочий стол/try/node_modules/koa-jwt/lib/index.js"],"names":["pAny","require","unless","verify","getSecret","resolveAuthHeader","resolveCookies","module","exports","opts","debug","getToken","isRevoked","key","passthrough","tokenKey","tokenResolvers","unshift","middleware","jwt","ctx","next","token","find","resolver","throw","state","secret","Error","secrets","Array","isArray","decodedTokens","map","s","decodedToken","catch","err","AggregateError","e","tokenRevoked","msg","message","originalError","jwtOriginalError"],"mappings":"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","sourcesContent":["'use strict';\n\nconst pAny = require('p-any');\nconst unless = require('koa-unless');\nconst verify = require('./verify');\nconst getSecret = require('./get-secret');\nconst resolveAuthHeader = require('./resolvers/auth-header');\nconst resolveCookies = require('./resolvers/cookie');\n\nmodule.exports = (opts = {}) => {\n    const { debug, getToken, isRevoked, key = 'user', passthrough, tokenKey } = opts;\n    const tokenResolvers = [resolveCookies, resolveAuthHeader];\n\n    if (getToken && typeof getToken === 'function') {\n        tokenResolvers.unshift(getToken);\n    }\n\n    const middleware = async function jwt(ctx, next) {\n        let token;\n        tokenResolvers.find(resolver => token = resolver(ctx, opts));\n\n        if (!token && !passthrough) {\n            ctx.throw(401, debug ? 'Token not found' : 'Authentication Error');\n        }\n\n        let { state: { secret = opts.secret } } = ctx;\n\n        try {\n            if (typeof secret === 'function') {\n                secret = await getSecret(secret, token)\n            }\n            \n            if (!secret) {\n                throw new Error('Secret not provided');\n            }\n\n            let secrets = Array.isArray(secret) ? secret : [secret];\n            const decodedTokens = secrets.map(async (s) => {\n                return await verify(token, s, opts)\n            });\n\n            const decodedToken = await pAny(decodedTokens)\n                .catch(function (err) {\n                    if (err instanceof pAny.AggregateError) {\n                        for (const e of err) {\n                            throw e;\n                        }\n                    } else {\n                        throw err;\n                    }\n                });\n\n            if (isRevoked) {\n                const tokenRevoked = await isRevoked(ctx, decodedToken, token);\n                if (tokenRevoked) {\n                    throw new Error('Token revoked');\n                }\n            }\n\n            ctx.state[key] = decodedToken;\n            if (tokenKey) {\n                ctx.state[tokenKey] = token;\n            }\n\n        } catch (e) {\n            if (!passthrough) {\n                const msg = debug ? e.message : 'Authentication Error';\n                ctx.throw(401, msg, { originalError: e });\n            }else{ \n                //lets downstream middlewares handle JWT exceptions\n                ctx.state.jwtOriginalError = e;\n            }\n        }\n\n        return next();\n    };\n\n    middleware.unless = unless;\n    return middleware;\n};\n"]},"metadata":{},"sourceType":"script"}